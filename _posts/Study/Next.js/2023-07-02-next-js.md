---
layout:   post
title:    'Next.js'
subtitle: 'Next.js 개념정리'
category: study
tags:     next-js
image: 
  path: /assets/img/next-js/next-js_main.jpg
accent_color: rgba(0,174,239,1)
accent_image:
  background: linear-gradient(225deg, rgba(27,10,58,1) 0%, rgba(0,174,239,1) 80%)
  overlay: false
theme_color: rgba(27,10,58,1)
---

* this undordered seed list will be replaced by the toc
{:toc .large-only}

## 1. What is Next.js?
---
The React Framework for the full-stack Web applications
- Full Stack
- File-based routing 
- SEO,Image,Font Optimization
- Server Side Rendering (+Hybrid Rendering)


### 1.1 React
---
A javascript library for building user interfaces.

- SPA (Single Page Application)
- CSR (Client Side Rendering)


### 1.2 Libraries vs Frameworks 
---

**Libraries**
- A tool that can be used to select only what is needed to solve a specific problem.

**Frameworks**
- Provides a solution for larger units rather than solving specific (small unit) problems.
- We can implement our logic within the designated <u>framework</u>.



### 1.3 History of Next.js
---

**OCT 2016**

PaaS (Cloud Platform As A Service)를 제공하는 Vercel에서  first release<br/>
*PaaS : A service that automatically manages the OS, hardware specs, etc., required to operate a service once it is deployed.

**6 Principles**
- ***out-of-the-box functionality requiring no setup***
- ***JavaScript everywhere(Frontned & Backend -> Full Stack)***
- ***automatic code-splitting[^1] and server-rendering***
- ***configurable data-fetching***
- ***anticipating requests***
- ***simplifying deployment*** 

[^1]: Instead of sending the entire bundled code to the user, it sends small pieces of the code corresponding to the part the user is viewing. (small -> fast)



**JULY 2020**
- Rewrite, Redirect
- Incremental Static Generation

**OCT 2022** (Next.js 13)
- new routing (/app)
- (nested) layouts
- Server Components
- streaming
- new toolchain (Turbopack)



### 1.4 CSR
---
**Cliend Side Rendering**
\: The entity that does the rendering is the client (browser)

**Process**
1. Browser requests the webpage.
2. Web server sends basic HTML, CSS, and JavaScript files to the client, which includes the React application code.
3. Browser renders HTML and CSS and then loads and executes JavaScript.
4. JavaScript initializes the React application.
5. React creates a DOM and renders it on the screen. React generates a virtual DOM based on the state and components of the webpage and updates the actual DOM incrementally.
6. As the application's state changes due to user interaction, React regenerates the virtual DOM and updates only the required parts of the actual DOM, thus enhancing performance.
7. If the application requires additional data, it communicates with the server via Ajax to fetch the data and update accordingly. Throughout this process, React provides a fast and sophisticated user experience.
   

**Advantages**
- Once loaded, it provides a fast UX
- Fetches data partially through Ajax and updates partially
- Low server load

**Disadvantages**
- Takes longer to load the page (TTV[^2]/FCP[^3])
- JavaScript activation is necessary
- SEO optimization is challenging
- Vulnerable to security issues
- Caching on CDN[^4] is not available

[^2]: Time To View
[^3]: First Contentful Paint
[^4]: Content Delievery Network

**⬇️To resolve these issues!⬇️**

### 1.5 SSG
---
**Static Site Generation**   
\: The entity that does the rendering is the server, renders at <span style='background-color: #E0FFC4'>***build time.***</span>

**Process**
1. The user requests a specific page from their web browser.
2. The hosting platform server sends the pre-built static HTML, CSS, and JavaScript files associated with the requested page to the user's browser. The browser does not need to make additional requests to the server for dynamic data as the content is pre-rendered during the build process.
3. The browser displays the initially rendered HTML and CSS content of the page. At this point, the user can see the page content. The JavaScript associated with the page, containing the React application code and any hydration logic, also begins loading and executing during this step.
4. When the JavaScript finishes loading and executing, the browser hydrates the necessary parts of the page. Hydration involves attaching the JavaScript event handlers and other interactive functionality to the static HTML content.
5. Once hydrated, the page provides full interactivity. If a part of the page needs to fetch additional data or update the content through user interactions or events, the application typically uses client-side data fetching (like fetch or a library such as Axios) to communicate with an API and update the content.

**Advantages**
- Fast page loading time (TTV/FCP)
- JavaScript is not required
- Good SEO optimization
- Excellent security
- Cached on CDN

**Disadvantages**
- Data is static
- Difficult to provide user-specific information

**⬇️To resolve these issues!⬇️**

### 1.6 SSR
___ 

**Process**
1. The user requests a specific page from their web browser.
2. The server receives the request and runs the getServerSideProps function, which fetches data or performs any necessary server-side computations. It then generates the final HTML, CSS, and JavaScript files, including the fetched data, and sends these files to the user's browser.
3. The browser displays the rendered HTML and CSS content of the page. At this point, users can see the page content. Concurrently, the browser loads and executes the JavaScript associated with the page, containing the React application code and any hydration logic.
4. After the JavaScript finishes loading and executing, the browser hydrates the necessary parts of the page. Hydration involves attaching JavaScript event handlers and other interactive functionality to the server-rendered HTML content.
5. Once hydrated, the page provides full interactivity. If a part of the page needs to fetch additional data or update content through user interactions or events, the application typically uses client-side data fetching (like fetch or a library such as Axios) to communicate with an API and update the content.