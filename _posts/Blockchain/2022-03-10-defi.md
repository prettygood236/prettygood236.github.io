---
layout:     post
title:     'DeFi'
subtitle:  'DeFi'
category:   blockchain
tags:       blockchain
image: 
  path: /assets/img/blockchain/defi_main.jpg
accent_color: rgba(57,54,87,1)
accent_image:
  background: rgba(116,172,209,1)
  overlay: false
theme_color: rgba(105,138,172,1)
---

* toc
{:toc .large-only}

블록체인이란 무엇인가요? 

블록체인은 네트워크의 여러 컴퓨터에서 업데이트되고 공유되는 공용 데이터베이스입니다.

"블록"은 "블록"으로 알려진 연속적인 그룹에 저장되는 데이터 및 상태를 나타냅니다. ETH를 다른 사람에게 보내는 경우 트랜잭션 데이터를 블록에 추가해야 성공할 수 있습니다.

"체인"은 각 블록이 부모를 암호화 방식으로 참조한다는 사실을 나타냅니다. 즉, 블록이 서로 연결됩니다. 블록의 데이터는 모든 후속 블록을 변경하지 않고는 변경할 수 없으며 전체 네트워크의 합의가 필요합니다.

네트워크의 모든 컴퓨터는 각각의 새로운 블록과 체인 전체에 반드시 동의해야 합니다. 이러한 컴퓨터를 "노드"라고 합니다. 노드는 블록체인과 상호 작용하는 모든 사람이 동일한 데이터를 갖도록 합니다. 이 분산 합의를 달성하기 위해 블록체인은 합의 메커니즘이 필요합니다.

Ethereum은 현재 작업 증명(PoW) 합의 메커니즘을 사용합니다. 즉, 체인에 새로운 블록을 추가하려는 사람은 많은 컴퓨팅 성능이 필요한 어려운 퍼즐을 풀어야 합니다. 퍼즐을 푸는 것은 계산 자원을 사용하여 "작업"을 완료했음을 "증명"합니다. 이 작업을 마이닝이라고 합니다. 채굴은 일반적으로 무차별 대입 시행착오이지만 블록을 성공적으로 추가하면 ETH로 보상을 받습니다.

새로운 블록은 네트워크의 모든 노드로 브로드캐스트되고 확인 및 검증되어 모든 노드의 블록체인 상태를 업데이트합니다.

요약하자면, ETH를 누군가에게 보낼 때 트랜잭션을 마이닝하여 새 블록에 포함해야 합니다. 업데이트된 상태는 전체 네트워크와 공유됩니다.




이더리움이란?

이더리움 세계에는 이더리움 네트워크의 모든 노드가 동의하는 상태의 단일 표준 컴퓨터(이더리움 가상 머신 또는 EVM이라고 함)가 있습니다. 이더리움 네트워크에 참여하는 모든 노드는 이 컴퓨터의 상태 사본을 보관합니다. 모든 참여자는 이 컴퓨터의 요청을 브로드캐스트하여 임의 계산을 수행합니다. 이러한 요청이 브로드캐스트될 때마다 네트워크의 다른 참가자는 계산을 확인, 검증 및 수행("실행")합니다. 이 실행으로 인해 EVM에서 상태 변경이 발생하고 이는 전체 네트워크에 커밋되고 전파됩니다.

계산 요청을 트랜잭션 요청이라고 합니다. 모든 거래 기록과 EVM의 현재 상태는 블록체인에 저장되며, 이를 차례로 모든 노드에서 저장하고 동의합니다.

암호화 메커니즘은 트랜잭션이 유효한 것으로 확인되고 블록체인에 추가되면 나중에 변조될 수 없도록 합니다. 암호화 메커니즘은 또한 모든 거래가 적절한 "권한"으로 서명되고 실행되도록 합니다(Alice 자신을 제외하고 아무도 Alice의 계정에서 디지털 자산을 보낼 수 없어야 함).


이더는 무엇입니까?
이더(ETH)는 이더리움의 기본 암호화폐입니다. 이더의 목적은 시장으로 하여금 사람들이 이더리움 네트워크에 참여하도록 이끌어 내는 것입니다. 시장은 참여자가 거래 요청을 확인 및 실행하고 네트워크에 계산 리소스를 제공할 때 경제적 인센티브를 제공합니다.

트랜잭션 요청을 브로드캐스트하는 모든 참여자는 현상금으로 네트워크에 일정량의 이더를 제공해야 합니다. 이 현상금은 거래를 확인하고, 실행하고, 블록체인에 커밋하고, 네트워크에 브로드캐스팅하는 작업을 수행하는 사람에게 수여됩니다.

지불된 이더의 양이 많을 수록 계산을 수행하는 데 필요한 시간이 짧아질 것입니다. 또한 이러한 현상금은 악의적인 참여자도 계산 시간에 대한 비용을 지불하게 하므로 infinite computation 또는 other resource-intensive scripts 실행 요청을 통한 의도적인 네트워크 방해를 막습니다.


스마트 컨트랙트란 무엇인가요?
실제로 참가자는 EVM에서 계산을 요청할 때마다 새 코드를 작성하지 않습니다. 오히려 애플리케이션 개발자는 프로그램(재사용 가능한 코드 조각)을 EVM 상태로 업로드하고 사용자는 다양한 매개변수를 사용하여 이러한 코드 조각을 실행하도록 요청합니다. 우리는 스마트 컨트랙트 네트워크에 업로드되고 실행되는 프로그램을 호출합니다.

쉽게 말하면, 스마트 컨트랙트는 일종의 자판기입니다. 특정 매개변수와 함께 호출될 때 특정 조건이 충족되면 일부 작업이나 계산을 수행하는 스크립트입니다. 예를 들어, 단순한 벤더 스마트 컨트랙트는 호출자가 특정 수신자에게 이더를 보내는 경우 디지털 자산의 소유권을 생성하고 할당할 수 있습니다.

모든 개발자는 네트워크에 요금을 지불해 블록체인을 데이터 계층으로 사용하여 스마트 컨트랙트를 생성하고 네트워크에 공개할 수 있습니다. 그런 다음 모든 사용자는 스마트 컨트랙트를 호출하여 코드를 실행할 수 있으며 이 때 마찬가지로 네트워크에 요금을 지불합니다.

따라서 스마트 컨트랙트를 통해 개발자는 시장, 금융 상품, 게임 등과 같이 복잡한 사용자 대면 앱 및 서비스를 구축하고 배포합니다.


용어 

블록체인
네트워크 히스토리에서 이더리움 네트워크에 커밋된 모든 블록의 시퀀스(순서있는 나열)입니다. 각 블록에는 이전 블록에 대한 참조가 포함되어 있기 때문에 이름이 지정되었습니다. 이는 모든 블록(정확한 기록을 유지)에 대한 순서를 유지하는 데 도움이 됩니다.

ETH
Ethereum의 기본 암호 화폐. 사용자는 코드 실행 요청을 위해 다른 사용자에게 이더를 지불합니다.

EVM
이더리움 가상 머신은 이더리움 네트워크의 모든 참가자가 상태를 저장하고 동의하는 글로벌 가상 컴퓨터입니다. 모든 참가자는 EVM에서 임의의 코드 실행을 요청할 수 있습니다. 코드 실행은 EVM의 상태를 변경합니다.

노드
EVM 상태를 저장하는 실제 기계. 노드는 EVM 상태 및 새 상태 변경에 대한 정보를 전파하기 위해 서로 통신합니다. 모든 사용자는 노드에서 코드 실행 요청을 브로드캐스트하여 코드 실행을 요청할 수도 있습니다. 이더리움 네트워크 자체는 모든 이더리움 노드와 통신의 집합체입니다.

어카운트
ETH가 저장되는 곳. 사용자는 어카운트를 초기화하고, 이더를 어카운트에 입금하고, 자신의 어카운트에서 다른 사용자에게 이더를 전송할 수 있습니다. 어카운트 및 어카운트 잔액은 EVM의 큰 테이블에 저장됩니다. 그것들은 전체 EVM 상태의 일부입니다.

트랜잭션
"트랜잭션 요청"은 EVM에서 코드 실행 요청에 대한 공식적인 용어이고 "트랜잭션"은 이행된 트랜잭션 요청 및 EVM 상태의 관련 변경입니다. 모든 사용자는 노드에서 네트워크로 트랜잭션 요청을 브로드캐스트할 수 있습니다. 트랜잭션 요청이 합의된 EVM 상태에 영향을 미치려면 다른 노드에서 검증, 실행 및 "네트워크에 커밋"해야 합니다. 코드를 실행하면 EVM의 상태가 변경됩니다. 확약 시 이 상태 변경은 네트워크의 모든 노드에 브로드캐스트됩니다. 거래의 몇 가지 예:

내 계정에서 앨리스의 계정으로 X 이더를 보냅니다.
일부 스마트 컨트랙트 코드를 EVM 상태로 게시합니다.
인수 Y를 사용하여 EVM의 주소 X에서 스마트 계약 코드를 실행합니다.

블록
트랜잭션 볼륨이 매우 높기 때문에 트랜잭션은 일괄 처리 또는 블록 단위로 "커밋"됩니다. 블록에는 일반적으로 수십에서 수백 개의 트랜잭션이 포함됩니다.

스마트 컨트랙트
개발자가 EVM 상태로 게시하는 재사용 가능한 코드 스니펫(프로그램). 트랜잭션 요청을 통해 누구나 스마트 컨트랙트 코드의 실행을 요청할 수 있습니다. 개발자는 스마트 컨트랙트를 게시하여 EVM(게임, 시장, 금융 상품 등)에 임의의 실행 가능한 애플리케이션을 작성할 수 있기 때문에 종종 dapp 또는 분산 앱이라고도 합니다.



### # 질문에 답하기

**Q1. 비트코인은 왜 튜링 불완전성인가요? 스마트 컨트랙트가 포함된 이더리움은 왜 튜링 완전인가요?**

A1. 

**Q2. 하이퍼레저 패브릭에서 사용되는 체인링크와 이더리움에서 사용되는 솔리디티의 차이점은 무엇인가요?**

A2. 

**Q3. EVM은 무엇인가요? EOS VM은 무엇인가요? 두개의 차이점은 무엇인가요? 왜 JVM으로 만들어졌나요?**

A3. 

**Q4. Banchor 알고리즘이 무엇인가요? 왜 뱅코르 알고리즘이 있는데 유니스왑을 사용하나요?**

A4. 

**Q5. 이더리움의 Solidity 언어와 다르게, Go, C++을 사용하면 비결정적 문제가 생깁니다. 무슨 의미인가요?**

A5. 

**Q6. 이더리움의 Solidity 언어는 어떤식으로 리소스에 대한 과금을 하나요?**

A6. 

**Q7. Solidity 처럼 C++이나 Go로 만든 프로그램에서 CPU,Memory,Storage 를 사용한 만큼의 지표를 구하고 싶을 때 어떻게 할 수 있을까요?**

A7. 

**Q8. 이더리움 스마트 컨트랙트에서는 왜 타이머나 이벤트를 사용할 수 없나요?**

A8. 

**Q9. 여러 계약이 엮인 파일을 배포하려고 하면 무슨 일이 발생하나요?**

A9. 

**Q10. 노드는 어떻게 스마트 컨트랙트 코드를 실행하나요?**

A10. 

**Q11. dApp이란 무엇이고 일반적인 어플리케이션과는 무엇이 다른가요?**

A11. 

**Q12. EVM 메모리의 구성 요소가 어떻게 되나요?**

A12. 

**Q13. 스마트 컨트랙트의 실행 비용이 지정된 가스보다 더 많이 소요된다면 무슨 일이 일어나나요?**

A13. 

**Q14. 트랜잭션에서 가스 사용량은 무엇에 따라 달라지며, 트랜잭션 수수료는 어떻게 계산되나요?**

A14. 






<br/>
<br/>
<br/>

[https://www.codestates.com/](https://www.codestates.com/){:target="_blank"}<br/>
{:.note title="reference"}
