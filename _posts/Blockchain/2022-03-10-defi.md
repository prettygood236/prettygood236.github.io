---
layout:     post
title:     'DeFi'
subtitle:  'DeFi'
category:   blockchain
tags:       blockchain
image: 
  path: /assets/img/blockchain/defi_main.jpg
accent_color: rgba(57,54,87,1)
accent_image:
  background: linear-gradient(to right bottom, rgba(37,46,59,1), rgba(53,67,84,1), rgba(70,89,110,1), rgba(86,112,137,1), rgba(103,136,165,1), rgba(104,137,168,1), rgba(105,138,172,1), rgba(106,139,175,1), rgba(93,117,153,1), rgba(81,95,131,1), rgba(69,74,109,1), rgba(57,54,87,1));
  overlay: false
theme_color: rgba(105,138,172,1)
---

* toc
{:toc .large-only}

스마트 컨트랙트
스마트 컨트랙트는 블록체인 네트워크에 호스팅되고 실행되는 프로그램입니다. 스마트 컨트랙트는 조건을 지정해두고, 해당 조건이 충족되면 미리 정해둔 계약을 이행하는 방식으로 코드를 작성합니다. 스마트 컨트랙트는 일반적인 중앙 집중식 서버가 아니라 탈중앙화된 블록체인에서 실행하기 때문에, 계약 조건이나 이행 내용을 변조하기 어려우며 계약을 신뢰하기 위한 제삼자가 필요하지 않습니다.


스마트 컨트랙트의 역사
스마트 컨트랙트의 개념은 1994년 닉 재보(Nick Szabo)에 의해 만들어졌습니다. 닉 사보는 스마트 컨트랙트를 다음과 같이 정의했습니다.

"계약 조건을 실행하는 전산화된 트랜잭션 프로토콜"은 "일반적인 계약 조건을 만족하고, 악의적이거나 우발적인 예외를 최소화하며, 신뢰할만한 중개자의 필요성을 최소화하는 것"을 목표로 한다.

스마트 컨트랙트를 실제로 지원하기 시작한 첫 화폐는 2009년 출시된 비트코인입니다. 비트코인이 스마트 컨트랙트를 지원할 수 있는 핵심적인 이유는 비트코인의 핵심 기술인 블록체인이 디지털이며, 위조를 방지할 수 있고, 제삼자가 필요하지 않기 때문이었습니다.

이더리움은 여러개의 독립적인 스마트 컨트랙트를 동시에 실행할 수 있어서 월드 컴퓨터(World Computer)라고 불리기도 합니다.


스마트 컨트랙트의 동작 방식
if or when (이벤트 x가 실행되면) {  // 조건
	액션 y를 실행하라  // 계약 이행
}
코드가 블록체인 네트워크에 올라가면, 네트워크는 미리 결정된 조건이 충족되고, 검증된 경우 조건에 따른 액션을 실행합니다. 코드에 따라 계약이 실행됨을 보장하는 결정론적인 상태(Deterministic State)인 다자간 디지털 계약이 바로 스마트 컨트랙트입니다.


스마트 컨트랙트의 장점
보안: 계약에 대한 중앙화된 공격 지점이 없고, 누군가에게 뇌물을 주고 계약 내용이나 결과를 변조할 위험이 없습니다.
신뢰성: 스마트 컨트랙트 로직이 조건에 부합해 계약이 이행되면 블록체인 네트워크에 있는 노드들에 의해 여러번 수행되고 검증되기 때문에, 위변조가 매우 어렵고 정확성이 높습니다.
공평함: 계약 조건을 공유하고 강제하기 위해 분산화된 블록체인 네트워크를 사용하기 때문에, 수수료를 가져가는 등 영리적 목적의 중개자가 필요하지 않습니다.
효율성: 계약 이행을 자동화하기 때문에 계약 당사자들은 수동으로 데이터를 입력하거나, 상대방의 계약 의무 이행 여부 검증하거나, 중개자가 계약을 집행하는지 확인할 필요가 없습니다.

UTXO 동작원리
트랜잭션의 구조
image

[스마트 컨트랙트&핵심 요약-그림.1] 트랜잭션 구조

출력에는 자산이 잠겨있고, 입력으로 출력을 해제하여 출력에 있는 값을 꺼내, 새로운 출력에 자산을 담습니다. 트랜잭션에는 다른 곳에 잠겨있는 출력을 해제하는 입력과, 입력의 결과로 생긴 새로운 출력이 담기게 됩니다. 따라서 트랜잭션은 이전 출력을 해제하고, 새로운 출력을 만드는 추상적인 "액션"이라고 볼 수 있습니다. 이렇게 입력에 의해 생성된 후, 다른 입력에 의해 해제되지 않은 트랜잭션 출력을 UTXO라고 합니다.


비트코인에서의 스마트 컨트랙트
비트코인에서는 스크립트(Script)라는 스크립터 언어를 사용해 스마트 컨트랙트를 구현합니다. 이 스크립트 실행을 통해 비트코인의 송금이 이루어집니다. 비트코인 스크립트는 일반적인 프로그래밍 언어와는 다르게 어떤 공식적인 문법이나 구문이 있는 것은 아닙니다. 대신 간단한 연산 목록으로 구성되어 있습니다.

이 스크립트 실행을 통해 비트코인의 송금이 이루어집니다. 이러한 특징으로 인해 비트코인은 프로그래밍 가능한 화폐(Programmable Money)에 대한 대중성을 부여했다고 볼 수 있습니다.

스크립트 동작원리
스크립트는 역폴란드 표기법(Reverse Polish Notation)으로 작성된 스택 기반 튜링 불완전 언어입니다.

스크립트 프로그램은 두 종류의 객체를 가지고 있습니다.

Opcode: 덧셈, 뺄셈, 곱셈과 같은 연산 작업을 나타냅니다.
데이터: OP_CODE가 아닌 모든 데이터는 원시 데이터로 해석되며, 스택에 들어가게 됩니다.
노드가 네트워크로부터 새로운 트랜잭션을 받으면, ScriptSig와 ScriptPubkey 필드를 추출하여 연결하여 최종적으로 <ScriptSig><ScriptPubkey> 형태의 스크립트를 얻게 됩니다.

스크립트는 이 Opcode와 DATA를 일렬로 늘어놓은 것입니다. 여기서 포인터(Pointer)는 일렬로 늘어진 Opcode와 데이터를 순서대로 하나씩 가리킵니다. 만약 포인터가 데이터를 가리키면 데이터를 스택에 넣고, Opcode를 가리키면 스택에서 데이터를 꺼내옵니다. Opcode는 스택에서 데이터를 하나 이상 가져올 수 있지만, 중요한 것은 스택 구조이기 때문에 가장 나중에 들어온 데이터부터 가져온다는 것입니다.

image

[스마트 컨트랙트&핵심 요약-그림.2] 스크립트


자주 쓰이는 비트코인 스크립트
Pay To PubKey(P2PK)
두 개의 데이터와 하나의 opcode만 사용하는 가장 간단한 종류의 비트코인 스크립트입니다. P2PK는 퍼블릭 키에 직접 코인을 송금하는 데 사용합니다. 수신자의 공개 키를 직접 노출하기 때문에 보안에 취약하며, 오늘날에는 사용되지 않습니다.

image

[스마트 컨트랙트&핵심 요약-그림.3] P2PK

PayToPubKeyHash(P2PKH)
P2PKH는 P2PK 메커니즘과 거의 동일하며, 한 가지 차이점은 P2PKH에서는 ScriptPubkey가 공개 키의 해시값을 가지고 있다는 점입니다.

image

[스마트 컨트랙트&핵심 요약-그림.4] P2PKH

P2PK와는 다르게, 서명과 공개키가 ScriptSig에 들어있습니다. ScriptPubkey는 P2PK에서와 다르게 여러개의 Opcode를 가지고 있으며, 수신자의 공개키를 해싱한 값인 Hash 1 객체가 들어있습니다. 비트코인을 보내는 동안 송신자는 공개키의 해시값을 보내기 때문에 스크립트 이름의 PayToPubkeyHash인 것입니다.


비트코인 스크립트가 스마트 컨트랙트인 이유
UTXO는 일종의 계약으로 정의될 수 있으며, 이 계약은 유효한 해제 조건이 주어지면 잠긴 비트코인을 이동시킵니다. 오직 유효한 해제 조건이 주어져야만 코인을 송금할 수 있는 계약인 것입니다. 이 계약의 실행은 비트코인 네트워크가 보장하기 때문에 계약 이행을 강제하기 위한 중개자가 필요하지 않습니다.


이더리움에서의 스마트 컨트랙트
이더리움은 블록체인 기술을 활용해 스마트 컨트랙트와 암호화폐 거래를 제삼자 없이 안전하게 이뤄질 수 있도록 하는 오픈소스 퍼블릭 서비스입니다. 누구든지 분산형 어플리케이션(dApp)을 이더리움 네트워크에 배포할 수 있습니다. 이더리움은 개발자들이 dApp을 만들 수 있도록 튜링 완전한 언어인 솔리디티(Solidity)를 제공하였으며, 이더리움 네트워크에 올라간 솔리디티 코드는 EVM(Ethereum Virtual Machine)을 통해 실행됩니다.


비트코인과 이더리움의 차이점
비트코인은 암호화폐를 거래하는 반면, 이더리움은 스마트 컨트랙트를 활용한 분산 어플리케이션(dApp)을 만들 수 있도록 솔리디티 언어와 EVM(Ethereum Virtual Machine)을 지원합니다.
비트코인은 무허가 퍼블릭 트랜잭션만을 허용하지만, 이더리움은 허가 트랜잭션과 무허가 트랜잭션을 모두 허용합니다.
비트코인에서는 플랫폼을 실행하고 트랜잭션을 검증하는 채굴 노드가 보상을 받습니다. 기본적으로 새로운 블록을 만드는 첫번째 컴퓨터가 비트코인을 보상으로 받습니다. 반면, 이더리움은 블록 생성에 대한 보상을 제공하지 않으며, 대신 채굴 노드가 트랜잭션 수수료를 받을 수 있도록 합니다.

EVM
image

[스마트 컨트랙트&핵심 요약-그림.5] EVM 계층

EVM(Ethereum Virtual Machine)은 우리가 짠 코드와 이더리움 블록체인 사이에 있는 가상 머신으로, 블록체인에서 코드가 실행될 수 있도록 합니다.

EVM은 솔리디티를 읽을 수 없기 때문에, 먼저 우리가 작성한 솔리디티 코드를 solc를 이용해 컴파일하여 EVM이 읽을 수 있는 바이트코드 형태로 만듭니다. 그리고 이 바이트코드를 Geth를 이용해 이더리움 네트워크에 올립니다. EVM에서는 바이트코드를 Opcode로 변환하여 실행합니다.

image

[스마트 컨트랙트&핵심 요약-그림.6] 솔리디티를 사용한 배포


솔리디티
솔리디티는 스마트 컨트랙트를 실행하는 객체 지향(Object-Oriented), 정적 타입(Static Typed), 고급(High-Level) 스크립트 언어로, EVM에서 실행됩니다.

솔리디티는 튜링 완전 언어이다
튜링 머신은 실제로 구현된 기계가 아니라, 이론상으로 존재하는 기계로, 오늘날 우리가 구축할 수 있는 가장 강력한 기계 컴퓨터를 설명할 때 사용하는 수학적 연산 모델입니다.

어떤 프로그래밍 언어나 추상 기계가 튜링 머신과 동일한 연산 능력을 가질 때, 우리는 그것이 튜링 완전(Turing-Complete)하다고 말합니다. 반대로 튜링 머신보다 연산 능력이 떨어질 경우 튜링 불완전(Turing-Incomplete)하다고 합니다.


스마트 컨트랙트와 튜링 완전, 불완전성
사토시 나카모토는 무한 반복 공격과 같은 보안상의 이슈를 고려해 의도적으로 반복문 Opcode를 제외했습니다. 따라서 비트코인 스크립트를 두고 튜링 불완전하다고 말합니다.

비트코인으로 스마트 컨트랙트를 구현할 때는 반복문을 사용할 수 없다 보니, 단순한 스마트 컨트랙트를 만드는 데에 그칠 수밖에 없었습니다. 이더리움의 핵심은 이러한 비트코인의 튜링불완전성이라는 한계를 넘어, 개발자가 원하는 스마트 컨트랙트를 유연하게 구현할 수 있도록 튜링 완전을 제공하는 것입니다. EVM은 반복문 Opcode들을 지원하는 대표적인 튜링 완전 머신이며, 솔리디티는 튜링 완전 머신을 동작하게 하는 튜링 완전 언어입니다.


솔리디티 개발 도구
Remix IDE
solc
Ganache
TestNet
Truffle, Embark, Dapple

스마트 컨트랙트 동작 원리
이더리움 상태 머신
이더리움은 거래에 기반을 둔 상태 머신(Transaction-based state machine)입니다. 상태 머신이란 일련의 입력을 읽고, 그 입력을 기반으로 새로운 상태로 전환하는 것을 의미합니다. 이더리움의 상태에는 수천 개의 트랜잭션이 있습니다. 이 트랜잭션은 블록이라는 그룹에 묶여 있으며, 블록은 직전에 만들어진 블록과 이어져 있습니다.

image

[스마트 컨트랙트&핵심 요약-그림.7] 이더리움의 트랜잭션 블록


EOS와 CA
이더리움에는 EOS(External Owned Account)와 CA(Contract Account)라는 두 종류의 계정이 있습니다. 모든 계정은 주소로 식별되며, 동일한 주소 공간을 가집니다.

EOS와 CA 모두 잔액(Balance), 논스(Nonce), 스토리지(Stroage), 컨트랙트 코드(Contract Code)로 구성되어 있습니다.

Balance: 계정의 현재 이더 잔고
Nonce: EOA의 경우, 해당 EOA로부터 보내진 트랜잭션의 숫자. CA의 경우, 해당 CA로부터 생성된 컨트랙트의 숫자를 의미합니다.
StorageRoot: 머클 패트리샤 트리의 루트 노드를 해싱한 값.
Contract Code: EVM이 실행할 코드의 해싱된 값. EOA에는 코드를 저장할 수 없기 때문에 비어있습니다.
CA는 스스로 새로운 트랜잭션을 만들 수 없습니다. CA는 EOS나 다른 CA에게서 받은 트랜잭션에 대한 응답에 대해서만 트랜잭션을 만들 수 있습니다.


전역 상태
이더리움의 전역 상태는 계정 주소와 계정 상태를 매핑한 것으로 구성되어 있습니다. 이 매핑은 머클 패트리샤 트리(Merkle Patricia Tree) 형태로 저장되어 있습니다.

머클 패트리샤 트리에서 변조가 시도되면 그 즉시 발견되기 때문에, 루트 노드는 데이터에 대한 ID처럼 사용될 수 있습니다. 또한 블록 헤더는 상태, 트랜잭션, 영수증 트리의 루트 노드 값을 가지고 있기 때문에, 네트워크의 노드들은 모든 상태를 저장하고 있지 않더라도 이더리움의 상태 일부분을 검증할 수 있습니다.


트랜잭션과 메시지
트랜잭션은 메시지 호출(Message Call)과 컨트랙트 생성(Contract Creations) 두 종류로 나뉩니다.

이더리움의 모든 트랜잭션은 항상 EOA에서 만들어지고 블록체인에 올라갑니다. 즉, 트랜잭션은 외부 세계를 이더리움 내부의 상태로 연결해주는 다리와 같습니다. 연결의 창구가 CA인 것입니다.


CA 생성
논스를 0으로 설정한다.
송신자가 CA 생성 트랜잭션에 이더를 함께 보낸 경우, 이를 CA의 잔금(Balance)으로 설정한다.
잔금에서 value 만큼을 제외한다.
CA의 스토리지를 빈 값으로 초기화한다.
CA의 코드를 빈 문자열의 해시값으로 초기화한다.
계약을 초기화하는 이 init 코드를 실행할 때는 가스를 사용합니다. 트랜잭션은 남아있는 가스보다 더 많은 가스를 소비할 수 없기 때문에, 만약 남아있는 가스를 다 사용한 경우 OOG(Out-of-Gas) 예외처리와 함께 코드 실행이 종료됩니다. OOG로 인한 트랜잭션 종료가 발생하면 상태는 트랜잭션 실행 이전 상태로 돌아갑니다.


트랜잭션 실행 모델과 EVM
image

image

[스마트 컨트랙트&핵심 요약-그림8, 9] EVM의 구성 요소, EVM 실행 모델

스마트 컨트랙트 실행 비용
이더리움에서 가장 중요한 개념 중 하나는 트랜잭션 실행 수수료입니다. 이더리움에서 트랜잭션의 결과로 발생하는 모든 연산은 수수료를 요구합니다. 이 수수료를 가스(Gas)라고 합니다.

가스는 트랜잭션 코드에 있는 모든 Opcode를 실행하는데 필요한 수수료를 측정하는 데 사용하는 단위입니다. Gas Price은 가스 당 지불하려고 하는 이더의 양을 의미하며, Gwei라는 단위를 사용합니다.

트랜잭션 송신자는 Gas Limit과 Gas Price를 트랜잭션에 지정합니다. 이 Gas Price와 Gas Limit은 송신자가 트랜잭션을 실행하는데 지불하고자 하는 Wei의 최대 양을 의미합니다.

채굴자는 연산을 수행하고 트랜잭션을 검증하는 데에 자원을 소모하기 때문에 이에 대한 보상으로 가스 수수료를 받습니다.


수수료를 지불하는 이유
이더리움은 튜링 완전 언어이기 때문에, 튜링 불완전한 비트코인 스크립트와는 달리 반복문을 지원합니다. 그러나 반복문의 가장 큰 단점은 무한 루프 문제가 일어날 수 있다는 것입니다. 만약 악의적인 사용자가 큰 자원을 소모하는 무한 루프 코드가 들어있는 트랜잭션을 실행시킨다면, 트랜잭션은 이더리움 네트워크의 엄청난 양의 자원을 소모하게 될 것이고, 심각하게는 이더리움 네트워크 전체가 멈출 수도 있습니다.

수수료는 이러한 악의적인 공격으로부터 네트워크를 보호합니다. 각 연산마다 수수료를 부과하면 악의적인 사용자라도 수수료를 지불해야 하기 때문에 쉽게 무한 루프 코드를 실행시킬 수 없습니다. 또한 의도치 않게 무한 루프를 만든 코드를 실행시키더라도 Gas Limit을 설정해두면 지정해둔 가스를 다 소모하기 전에 실행을 멈출 수 있습니다.


프라이빗 블록체인에서의 스마트 컨트랙트
프라이빗 블록체인은 네트워크 내에서 초대된 사용자만이 네트워크에 참여하고, 원장에 접근할 수 있는 허가형(Permissioned) 블록체인을 의미합니다. 프라이빗 블록체인은 채굴 과정과 합의 알고리즘에 대한 권한을 중앙 기관이 개발하고 유지합니다. 중앙 기관은 네트워크에 참여할 수 있는 사용자를 결정합니다.

프라이빗 블록체인의 특징
높은 효율성
완전한 개인 정보 보안
불법적 활동 제한

퍼블릭 블록체인과 프라이빗 블록체인의 차이
차이점	퍼블릭 블록체인	프라이빗 블록체인
중앙 기관의 여부	온전한 탈중앙화가 이루어집니다.	프라이빗 블록체인에서는 전체 시스템을 감시하는 중앙 기관이 존재합니다. 따라서 퍼블릭 블록체인 플랫폼처럼 완전히 탈중앙화 되지 않았지만, 부분적으로 분산된 시스템을 구축할 수는 있습니다.
접근 권한	누구든지 네트워크에 참여할 수 있으며, 원장에 대한 합의 과정에 참여할 수 있습니다.	중앙 기관이 네트워크에 대한 관리 권한을 가집니다. 그리고 이러한 중앙 기관은 프라이빗 블록체인에 누가 접근하는지 확인하기 위한 인증 프로세스를 가지고 있습니다.
트랜잭션 비용	프라이빗 블록체인에 비해 트랜잭션 비용이 높습니다. 또한 노드 수가 많아 트랜잭션이 많으면 트랜잭션이 완료되기까지 시간이 오래 걸리기도 합니다. 이로 인해 트랜잭션 수수료의 변동폭이 크다는 단점이 있습니다.	채굴이나 트랜잭션 수수료가 매우 적거나, 아예 존재하지 않기도 합니다.
합의	노드들은 누구나 자유롭게 합의 과정에 참여할 수 있습니다.	누가 합의 과정에 참여할 수 있는지 미리 결정해둡니다. 따라서 많은 노드들이 합의 과정에 참여하지 않기도 합니다.
데이터 처리	누구나 원장을 읽거나 쓸 수 있습니다. 그리고 한번 원장이 체인에 올라가면 수정할 수 없습니다.	중앙 기관이 특정 노드만 원장을 쓸 수 있도록 지정할 수 있습니다. 경우에 따라서 중앙 기관이 블록을 삭제할 수도 있습니다.

대표적인 프라이빗 블록체인
하이퍼레저
R3
넥스레저

하이퍼레저 패브릭과 체인코드
하이퍼레저 패브릭의 블록체인적 특징
프라이버시와 기밀성: 패브릭의 채널(Channel)은 네트워크의 특정 하위 노드 집합에게 트랜잭션 프라이버시와 기밀성을 보장해줍니다.
효율적인 처리: 네트워크의 동시성과 병렬성을 제공하여, 트랜잭션 실행을 트랜잭션 정렬 및 커밋과 분리합니다.
체인코드 기능: 이더리움의 스마트 컨트랙트에 해당하는 체인코드를 제공합니다.
모듈식 설계: 아키텍쳐들을 모듈식으로 구현하여 필요한 모듈들을 가져다 쓸 수 있도록 선택권을 제공합니다.

하이퍼레저 패브릭의 주요 개념
피어(Peer) 피어는 블록체인 네트워크의 기본 요소이며, 원장과 스마트 컨트랙트를 호스팅하는 노드입니다. 네트워크와의 상호작용의 시작점이며, 어플리케이션이 체인코드(스마트 컨트랙트)를 실행하여 쿼리를 하거나 원장을 업데이트하도록 합니다.
커밋 피어와 보증 피어로 나뉩니다.
채널(Channel) 하이퍼레저 패브릭 채널은 둘 이상의 특정 네트워크 노드 간의 통신을 위한 프라이빗 서브넷으로, 프라이빗 트랜잭션을 수행하기 위한 목적으로 사용됩니다.

스마트 컨트랙트와 체인 코드
스마트 컨트랙트는 트랜잭션을 관리하며, 체인 코드는 스마트 컨트랙트를 배포하기 위해 패키징하여 관리합니다.


이더리움과 하이퍼레저 패브릭의 차이점
플랫폼의 목적: 이더리움은 EVM 위에서 스마트 컨트랙트를 실행하는 하나의 목적을 위해 만들어졌습니다. 하이퍼레저는 고성능과 신뢰성이 높은 블록체인 개발을 위한 산업 전반의 협업을 가속화하기 위해 도입되었습니다.
작동 방식: 이더리움은 퍼블릭 블록체인으로, 누구나 블록체인 네트워크에 접근할 수 있고, 네트워크에 접근할 때 허가를 받을 필요가 없습니다. 반면, 하이퍼레저 패브릭은 프라이빗 블록체인으로, 허가된 사용자만이 네트워크에 참여할 수 있습니다.
피어 역할: 이더리움은 트랜잭션이 완료되면 이를 위해 여러 노드가 참여해야 하므로 확장성, 프라이버시, 효율성 등의 문제가 발생할 수 있습니다. 하이퍼레저는 네트워크 내의 각 피어에게 트랜잭션을 수행하기 위해 정보를 제공할 필요가 없는 DLT(Distributed Ledger Technology)를 제공합니다.
기밀성: 이더리움은 퍼블릭 네트워크이기 때문에, 블록체인 네트워크에 기록된 모든 트랜잭션에 누구든지 접근할 수 있습니다. 하이퍼레저는 허가형 프라이빗 네트워크이기 때문에 허가된 멤버만 트랜잭션에 접근할 수 있습니다.
합의 메커니즘: 이더리움은 모든 노드가 합의에 도달해야 하는 PoW 합의 알고리즘을 사용합니다. 반면, 하이퍼레저 패브릭은 다른 종류의 합의 알고리즘을 사용합니다. 하이퍼레저 패브릭에서는 아예 합의를 하지 않거나, 다양한 합의 프로토콜 중 하나를 선택할 수 있습니다.
프로그래밍 언어: 이더리움은 이더리움의 자체 언어인 솔리디티를 사용하지만, 하이퍼레저에서는 Go언어를 사용합니다.

스마트 컨트랙트를 활용한 새로운 서비스들
금융 상품(DeFi)
게임 및 NFT
DAO
ICO
브릿지

스마트 컨트랙트 활용 사례
일정한 형식의 반복적인 계약이 많은 경우
사례: 보험
원격자 간 계약 체결이 필요한 경우
사례: 자동차 렌탈 서비스
제품의 유통 추적이 필요한 경우
사례: 물류 유통

오라클 문제
오라클
오라클은 web API나 마켓 데이터 피드와 같은 방식을 통해 블록체인과 스마트 컨트랙트용 외부 데이터를 검색하고 검증하는 것을 의미합니다.


오라클 문제
오라클 문제는 서드 파티 오라클과 스마트 컨트랙트의 무신뢰성 실행 간 보안, 인증, 신뢰 충돌 문제에 관한 것입니다. 스마트 컨트랙트는 주어진 데이터에 따라 계약 이행 여부를 결정할 뿐이지, 데이터에 대한 자체적인 판단 능력은 가지고 있지 않습니다.


컴퓨터에서의 난수 생성
컴퓨터는 입력받은 값에 대해 정해진 행동을 하기 때문에, 조종할 수 없는 새로운 데이터를 생성하는 것을 잘 하지 못합니다. 따라서 컴퓨터 과학에서 난수는 유사 난수(Pseudo Random)와 진짜 난수(True Random)로 나뉩니다. 유사 난수는 컴퓨터에 있는 데이터와 알고리즘을 통해 얻게 되는 난수입니다. 이 난수는 컴퓨터 내부에 있는 알고리즘과 데이터를 가지고 생성되었기 때문에 특정한 패턴을 가지게 되고, 이로 인해 예측할 수 있습니다.


블록체인에서의 난수 생성 문제
블록체인에서는 모든 노드들이 트랜잭션을 검증함으로써 데이터의 무결성을 보장하기 때문에, 블록체인에서 일어나는 모든 동작은 결정적인 방식으로 일어납니다.

예를 들어, 이더리움 스마트 컨트랙트에는 랜덤 함수가 구현되어 있지 않습니다. 노드들이 블록을 검증하기 위해서는 블록에 있는 트랜잭션을 실행한 결과 상태값과 현재 자신이 가지고 있는 상태값을 비교해야 합니다. 그런데 트랜잭션에서 무작위 값이 나오면 트랜잭션을 실행한 결과 상태값이 매번 변할 것이기 때문에 데이터의 무결성을 증명하기가 매우 어려워집니다.

그러나 우리가 원하는 난수 생성은 결정적이면 안됩니다. 매번 예측할 수 없는 값이 나와야 예측하거나 조작할 수 없기 때문입니다.


블록체인 난수를 생성하는 방법
Commit Reveal Scheme
BLS Scheme


### # 질문에 답하기

**Q1. 비트코인은 왜 튜링 불완전성인가요? 스마트 컨트랙트가 포함된 이더리움은 왜 튜링 완전인가요?**

A1. 

**Q2. 하이퍼레저 패브릭에서 사용되는 체인링크와 이더리움에서 사용되는 솔리디티의 차이점은 무엇인가요?**

A2. 

**Q3. EVM은 무엇인가요? EOS VM은 무엇인가요? 두개의 차이점은 무엇인가요? 왜 JVM으로 만들어졌나요?**

A3. 

**Q4. Banchor 알고리즘이 무엇인가요? 왜 뱅코르 알고리즘이 있는데 유니스왑을 사용하나요?**

A4. 

**Q5. 이더리움의 Solidity 언어와 다르게, Go, C++을 사용하면 비결정적 문제가 생깁니다. 무슨 의미인가요?**

A5. 

**Q6. 이더리움의 Solidity 언어는 어떤식으로 리소스에 대한 과금을 하나요?**

A6. 

**Q7. Solidity 처럼 C++이나 Go로 만든 프로그램에서 CPU,Memory,Storage 를 사용한 만큼의 지표를 구하고 싶을 때 어떻게 할 수 있을까요?**

A7. 

**Q8. 이더리움 스마트 컨트랙트에서는 왜 타이머나 이벤트를 사용할 수 없나요?**

A8. 

**Q9. 여러 계약이 엮인 파일을 배포하려고 하면 무슨 일이 발생하나요?**

A9. 

**Q10. 노드는 어떻게 스마트 컨트랙트 코드를 실행하나요?**

A10. 

**Q11. dApp이란 무엇이고 일반적인 어플리케이션과는 무엇이 다른가요?**

A11. 

**Q12. EVM 메모리의 구성 요소가 어떻게 되나요?**

A12. 

**Q13. 스마트 컨트랙트의 실행 비용이 지정된 가스보다 더 많이 소요된다면 무슨 일이 일어나나요?**

A13. 

**Q14. 트랜잭션에서 가스 사용량은 무엇에 따라 달라지며, 트랜잭션 수수료는 어떻게 계산되나요?**

A14. 






<br>
<br>
<br>

[https://www.codestates.com/](https://www.codestates.com/){:target="_blank"}<br>
{:.note title="reference"}
